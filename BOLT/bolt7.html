<h1 id="bolt7p2pnodeandchanneldiscovery">BOLT #7: P2P Node and Channel Discovery</h1>

<p>This specification describes simple node discovery, channel discovery, and channel update mechanisms that do not rely on a third-party to disseminate the information.</p>

<p>Node and channel discovery serve two different purposes:</p>

<ul>
<li>Channel discovery allows the creation and maintenance of a local view of the network's topology, so that a node can discover routes to desired destinations.</li>

<li>Node discovery allows nodes to broadcast their ID, host, and port, so that other nodes can open connections and establish payment channels with them.</li>
</ul>

<p>To support channel discovery, three <em>gossip messages</em> are supported.   Peers in the network exchange
<code>channel_announcement</code> messages containing information regarding new
channels between the two nodes. They can also exchange <code>channel_update</code>
messages, which update information about a channel. There can only be
one valid <code>channel_announcement</code> for any channel, but at least two
<code>channel_update</code> messages are expected.</p>

<p>To support node discovery, peers exchange <code>node_announcement</code>
messages, which supply additional information about the nodes. There may be
multiple <code>node_announcement</code> messages, in order to update the node information.</p>

<h1 id="tableofcontents">Table of Contents</h1>

<ul>
<li><a href="#the-announcement_signatures-message">The <code>announcement_signatures</code> Message</a></li>

<li><a href="#the-channel_announcement-message">The <code>channel_announcement</code> Message</a></li>

<li><a href="#the-node_announcement-message">The <code>node_announcement</code> Message</a></li>

<li><a href="#the-channel_update-message">The <code>channel_update</code> Message</a></li>

<li><a href="#query-messages">Query Messages</a></li>

<li><a href="#initial-sync">Initial Sync</a></li>

<li><a href="#rebroadcasting">Rebroadcasting</a></li>

<li><a href="#htlc-fees">HTLC Fees</a></li>

<li><a href="#pruning-the-network-view">Pruning the Network View</a></li>

<li><a href="#recommendations-for-routing">Recommendations for Routing</a></li>

<li><a href="#references">References</a></li>
</ul>

<h2 id="theannouncement_signaturesmessage">The <code>announcement_signatures</code> Message</h2>

<p>This is a direct message between the two endpoints of a channel and serves as an opt-in mechanism to allow the announcement of the channel to the rest of the network.
It contains the necessary signatures, by the sender, to construct the <code>channel_announcement</code> message.</p>

<ol>
<li>type: 259 (<code>announcement_signatures</code>)</li>

<li>data:


<ul>
<li>[<code>32</code>:<code>channel_id</code>]</li>

<li>[<code>8</code>:<code>short_channel_id</code>]</li>

<li>[<code>64</code>:<code>node_signature</code>]</li>

<li>[<code>64</code>:<code>bitcoin_signature</code>]</li></ul>
</li>
</ol>

<p>The willingness of the initiating node to announce the channel is signaled during channel opening by setting the <code>announce_channel</code> bit in <code>channel_flags</code> (see <a href="02-peer-protocol.md#the-open_channel-message">BOLT #2</a>).</p>

<h3 id="requirements">Requirements</h3>

<p>The <code>announcement_signatures</code> message is created by constructing a <code>channel_announcement</code> message, corresponding to the newly established channel, and signing it with the secrets matching an endpoint's <code>node_id</code> and <code>bitcoin_key</code>. After it's signed, the
<code>announcement_signatures</code> message may be sent.</p>

<p>The <code>short_channel_id</code> is the unique description of the funding transaction.
It is constructed as follows:</p>

<ol>
<li>the most significant 3 bytes: indicating the block height</li>

<li>the next 3 bytes: indicating the transaction index within the block</li>

<li>the least significant 2 bytes: indicating the output index that pays to the channel.</li>
</ol>

<p>The standard human readable format for <code>short_channel_id</code> is created
by printing the above components, in the order:
block height, transaction index, and output index.
Each component is printed as a decimal number,
and separated from each other by the small letter <code>x</code>.
For example, a <code>short_channel_id</code> might be written as <code>539268x845x1</code>,
indicating a channel on the output 1 of the transaction at index 845
of the block at height 539268.</p>

<p>A node:</p>

<ul>
<li>if the <code>open_channel</code> message has the <code>announce_channel</code> bit set AND a <code>shutdown</code> message has not been sent:


<ul>
<li>MUST send the <code>announcement_signatures</code> message.


<ul>
<li>MUST NOT send <code>announcement_signatures</code> messages until <code>funding_locked</code>
has been sent and received AND the funding transaction has at least six confirmations.</li></ul>
</li></ul>
</li>

<li>otherwise:


<ul>
<li>MUST NOT send the <code>announcement_signatures</code> message.</li></ul>
</li>

<li>upon reconnection (once the above timing requirements have been met):


<ul>
<li>MUST respond to the first <code>announcement_signatures</code> message with its own
<code>announcement_signatures</code> message.</li>

<li>if it has NOT received an <code>announcement_signatures</code> message:


<ul>
<li>SHOULD retransmit the <code>announcement_signatures</code> message.</li></ul>
</li></ul>
</li>
</ul>

<p>A recipient node:</p>

<ul>
<li>if the <code>node_signature</code> OR the <code>bitcoin_signature</code> is NOT correct:


<ul>
<li>MAY fail the channel.</li></ul>
</li>

<li>if it has sent AND received a valid <code>announcement_signatures</code> message:


<ul>
<li>SHOULD queue the <code>channel_announcement</code> message for its peers.</li></ul>
</li>

<li>if it has not sent funding_locked:


<ul>
<li>MAY defer handling the announcement<em>signatures until after it has sent funding</em>locked</li>

<li>otherwise:


<ul>
<li>MUST ignore it.</li></ul>
</li></ul>
</li>
</ul>

<h3 id="rationale">Rationale</h3>

<p>The reason for allowing deferring of a premature announcement_signatures is
that an earlier version of the spec did not require waiting for receipt of
funding locked: deferring rather than ignoring it allows compatibility with
this behavior.</p>

<p>The <code>short_channel_id</code> human readable format is designed
so that double-clicking or double-tapping it will select the entire ID
on most systems.
Humans prefer decimal when reading numbers,
so the ID components are written in decimal.
The small letter <code>x</code> is used since on most fonts,
the <code>x</code> is visibly smaller than decimal digits,
making it easy to visibly group each component of the ID.</p>

<h2 id="thechannel_announcementmessage">The <code>channel_announcement</code> Message</h2>

<p>This gossip message contains ownership information regarding a channel. It ties
each on-chain Bitcoin key to the associated Lightning node key, and vice-versa.
The channel is not practically usable until at least one side has announced
its fee levels and expiry, using <code>channel_update</code>.</p>

<p>Proving the existence of a channel between <code>node_1</code> and <code>node_2</code> requires:</p>

<ol>
<li>proving that the funding transaction pays to <code>bitcoin_key_1</code> and
<code>bitcoin_key_2</code></li>

<li>proving that <code>node_1</code> owns <code>bitcoin_key_1</code></li>

<li>proving that <code>node_2</code> owns <code>bitcoin_key_2</code></li>
</ol>

<p>Assuming that all nodes know the unspent transaction outputs, the first proof is
accomplished by a node finding the output given by the <code>short_channel_id</code> and
verifying that it is indeed a P2WSH funding transaction output for those keys
specified in <a href="03-transactions.md#funding-transaction-output">BOLT #3</a>.</p>

<p>The last two proofs are accomplished through explicit signatures:
<code>bitcoin_signature_1</code> and <code>bitcoin_signature_2</code> are generated for each
<code>bitcoin_key</code> and each of the corresponding <code>node_id</code>s are signed.</p>

<p>It's also necessary to prove that <code>node_1</code> and <code>node_2</code> both agree on the
announcement message: this is accomplished by having a signature from each
<code>node_id</code> (<code>node_signature_1</code> and <code>node_signature_2</code>) signing the message.</p>

<ol>
<li>type: 256 (<code>channel_announcement</code>)</li>

<li>data:


<ul>
<li>[<code>64</code>:<code>node_signature_1</code>]</li>

<li>[<code>64</code>:<code>node_signature_2</code>]</li>

<li>[<code>64</code>:<code>bitcoin_signature_1</code>]</li>

<li>[<code>64</code>:<code>bitcoin_signature_2</code>]</li>

<li>[<code>2</code>:<code>len</code>]</li>

<li>[<code>len</code>:<code>features</code>]</li>

<li>[<code>32</code>:<code>chain_hash</code>]</li>

<li>[<code>8</code>:<code>short_channel_id</code>]</li>

<li>[<code>33</code>:<code>node_id_1</code>]</li>

<li>[<code>33</code>:<code>node_id_2</code>]</li>

<li>[<code>33</code>:<code>bitcoin_key_1</code>]</li>

<li>[<code>33</code>:<code>bitcoin_key_2</code>]</li></ul>
</li>
</ol>

<h3 id="requirements-1">Requirements</h3>

<p>The origin node:</p>

<ul>
<li>MUST set <code>chain_hash</code> to the 32-byte hash that uniquely identifies the chain
that the channel was opened within:


<ul>
<li>for the <em>Bitcoin blockchain</em>:


<ul>
<li>MUST set <code>chain_hash</code> value (encoded in hex) equal to <code>6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000</code>.</li></ul>
</li></ul>
</li>

<li>MUST set <code>short_channel_id</code> to refer to the confirmed funding transaction,
as specified in <a href="02-peer-protocol.md#the-funding_locked-message">BOLT #2</a>.


<ul>
<li>Note: the corresponding output MUST be a P2WSH, as described in <a href="03-transactions.md#funding-transaction-output">BOLT #3</a>.</li></ul>
</li>

<li>MUST set <code>node_id_1</code> and <code>node_id_2</code> to the public keys of the two nodes
operating the channel, such that <code>node_id_1</code> is the numerically-lesser of the
two DER-encoded keys sorted in ascending numerical order.</li>

<li>MUST set <code>bitcoin_key_1</code> and <code>bitcoin_key_2</code> to <code>node_id_1</code> and <code>node_id_2</code>'s
respective <code>funding_pubkey</code>s.</li>

<li>MUST compute the double-SHA256 hash <code>h</code> of the message, beginning at offset
256, up to the end of the message.


<ul>
<li>Note: the hash skips the 4 signatures but hashes the rest of the message,
including any future fields appended to the end.</li></ul>
</li>

<li>MUST set <code>node_signature_1</code> and <code>node_signature_2</code> to valid
signatures of the hash <code>h</code> (using <code>node_id_1</code> and <code>node_id_2</code>'s respective
secrets).</li>

<li>MUST set <code>bitcoin_signature_1</code> and <code>bitcoin_signature_2</code> to valid
signatures of the hash <code>h</code> (using <code>bitcoin_key_1</code> and <code>bitcoin_key_2</code>'s
respective secrets).</li>

<li>SHOULD set <code>len</code> to the minimum length required to hold the <code>features</code> bits
it sets.</li>
</ul>

<p>The receiving node:</p>

<ul>
<li>MUST verify the integrity AND authenticity of the message by verifying the
signatures.</li>

<li>if there is an unknown even bit in the <code>features</code> field:


<ul>
<li>MUST NOT parse the remainder of the message.</li>

<li>MUST NOT add the channel to its local network view.</li>

<li>SHOULD NOT forward the announcement.</li></ul>
</li>

<li>if the <code>short_channel_id</code>'s output does NOT correspond to a P2WSH (using
<code>bitcoin_key_1</code> and <code>bitcoin_key_2</code>, as specified in
<a href="03-transactions.md#funding-transaction-output">BOLT #3</a>) OR the output is
spent:


<ul>
<li>MUST ignore the message.</li></ul>
</li>

<li>if the specified <code>chain_hash</code> is unknown to the receiver:


<ul>
<li>MUST ignore the message.</li></ul>
</li>

<li>otherwise:


<ul>
<li>if <code>bitcoin_signature_1</code>, <code>bitcoin_signature_2</code>, <code>node_signature_1</code> OR
<code>node_signature_2</code> are invalid OR NOT correct:


<ul>
<li>SHOULD fail the connection.</li></ul>
</li>

<li>otherwise:


<ul>
<li>if <code>node_id_1</code> OR <code>node_id_2</code> are blacklisted:</li>

<li>SHOULD ignore the message.</li>

<li>otherwise:</li>

<li>if the transaction referred to was NOT previously announced as a
channel:


<ul>
<li>SHOULD queue the message for rebroadcasting.</li>

<li>MAY choose NOT to for messages longer than the minimum expected
length.</li></ul>
</li>

<li>if it has previously received a valid <code>channel_announcement</code>, for the
same transaction, in the same block, but for a different <code>node_id_1</code> or
<code>node_id_2</code>:</li>

<li>SHOULD blacklist the previous message's <code>node_id_1</code> and <code>node_id_2</code>,
as well as this <code>node_id_1</code> and <code>node_id_2</code> AND forget any channels
connected to them.</li>

<li>otherwise:</li>

<li>SHOULD store this <code>channel_announcement</code>.</li></ul>
</li></ul>
</li>

<li>once its funding output has been spent OR reorganized out:


<ul>
<li>SHOULD forget a channel.</li></ul>
</li>
</ul>

<h3 id="rationale-1">Rationale</h3>

<p>Both nodes are required to sign to indicate they are willing to route other
payments via this channel (i.e. be part of the public network); requiring their
Bitcoin signatures proves that they control the channel.</p>

<p>The blacklisting of conflicting nodes disallows multiple different
announcements. Such conflicting announcements should never be broadcast by any
node, as this implies that keys have leaked.</p>

<p>While channels should not be advertised before they are sufficiently deep, the
requirement against rebroadcasting only applies if the transaction has not moved
to a different block.</p>

<p>In order to avoid storing excessively large messages, yet still allow for
reasonable future expansion, nodes are permitted to restrict rebroadcasting
(perhaps statistically).</p>

<p>New channel features are possible in the future: backwards compatible (or
optional) features will have <em>odd</em> feature bits, while incompatible features
will have <em>even</em> feature bits
(<a href="00-introduction.md#glossary-and-terminology-guide">"It's OK to be odd!"</a>).
Incompatible features will result in the announcement not being forwarded by
nodes that do not understand them.</p>

<h2 id="thenode_announcementmessage">The <code>node_announcement</code> Message</h2>

<p>This gossip message allows a node to indicate extra data associated with it, in
addition to its public key. To avoid trivial denial of service attacks,
nodes not associated with an already known channel are ignored.</p>

<ol>
<li>type: 257 (<code>node_announcement</code>)</li>

<li>data:


<ul>
<li>[<code>64</code>:<code>signature</code>]</li>

<li>[<code>2</code>:<code>flen</code>]</li>

<li>[<code>flen</code>:<code>features</code>]</li>

<li>[<code>4</code>:<code>timestamp</code>]</li>

<li>[<code>33</code>:<code>node_id</code>]</li>

<li>[<code>3</code>:<code>rgb_color</code>]</li>

<li>[<code>32</code>:<code>alias</code>]</li>

<li>[<code>2</code>:<code>addrlen</code>]</li>

<li>[<code>addrlen</code>:<code>addresses</code>]</li></ul>
</li>
</ol>

<p><code>timestamp</code> allows for the ordering of messages, in the case of multiple
announcements. <code>rgb_color</code> and <code>alias</code> allow intelligence services to assign
nodes colors like black and cool monikers like 'IRATEMONK' and 'WISTFULTOLL'.</p>

<p><code>addresses</code> allows a node to announce its willingness to accept incoming network
connections: it contains a series of <code>address descriptor</code>s for connecting to the
node. The first byte describes the address type and is followed by the
appropriate number of bytes for that type.</p>

<p>The following <code>address descriptor</code> types are defined:</p>

<ul>
<li><code>1</code>: ipv4; data = <code>[4:ipv4_addr][2:port]</code> (length 6)</li>

<li><code>2</code>: ipv6; data = <code>[16:ipv6_addr][2:port]</code> (length 18)</li>

<li><code>3</code>: Tor v2 onion service; data = <code>[10:onion_addr][2:port]</code> (length 12)


<ul>
<li>version 2 onion service addresses; Encodes an 80-bit, truncated <code>SHA-1</code>
hash of a 1024-bit <code>RSA</code> public key for the onion service (a.k.a. Tor
hidden service).</li></ul>
</li>

<li><code>4</code>: Tor v3 onion service; data = <code>[35:onion_addr][2:port]</code> (length 37)


<ul>
<li>version 3 (<a href="https://gitweb.torproject.org/torspec.git/tree/proposals/224-rend-spec-ng.txt">prop224</a>)
 onion service addresses; Encodes:
 <code>[32:32_byte_ed25519_pubkey] || [2:checksum] || [1:version]</code>, where
 <code>checksum = sha3(".onion checksum" | pubkey || version)[:2]</code>.</li></ul>
</li>
</ul>

<h3 id="requirements-2">Requirements</h3>

<p>The origin node:</p>

<ul>
<li>MUST set <code>timestamp</code> to be greater than that of any previous
<code>node_announcement</code> it has previously created.


<ul>
<li>MAY base it on a UNIX timestamp.</li></ul>
</li>

<li>MUST set <code>signature</code> to the signature of the double-SHA256 of the entire
remaining packet after <code>signature</code> (using the key given by <code>node_id</code>).</li>

<li>MAY set <code>alias</code> AND <code>rgb_color</code> to customize its appearance in maps and
graphs.


<ul>
<li>Note: the first byte of <code>rgb_color</code> is the red value, the second byte is the
green value, and the last byte is the blue value.</li></ul>
</li>

<li>MUST set <code>alias</code> to a valid UTF-8 string, with any <code>alias</code> trailing-bytes
equal to 0.</li>

<li>SHOULD fill <code>addresses</code> with an address descriptor for each public network
address that expects incoming connections.</li>

<li>MUST set <code>addrlen</code> to the number of bytes in <code>addresses</code>.</li>

<li>MUST place address descriptors in ascending order.</li>

<li>SHOULD NOT place any zero-typed address descriptors anywhere.</li>

<li>SHOULD use placement only for aligning fields that follow <code>addresses</code>.</li>

<li>MUST NOT create a <code>type 1</code> OR <code>type 2</code> address descriptor with <code>port</code> equal
to 0.</li>

<li>SHOULD ensure <code>ipv4_addr</code> AND <code>ipv6_addr</code> are routable addresses.</li>

<li>MUST NOT include more than one <code>address descriptor</code> of the same type.</li>

<li>SHOULD set <code>flen</code> to the minimum length required to hold the <code>features</code>
bits it sets.</li>
</ul>

<p>The receiving node:</p>

<ul>
<li>if <code>node_id</code> is NOT a valid compressed public key:


<ul>
<li>SHOULD fail the connection.</li>

<li>MUST NOT process the message further.</li></ul>
</li>

<li>if <code>signature</code> is NOT a valid signature (using <code>node_id</code> of the
double-SHA256 of the entire message following the <code>signature</code> field, including
any future fields appended to the end):


<ul>
<li>SHOULD fail the connection.</li>

<li>MUST NOT process the message further.</li></ul>
</li>

<li>if <code>features</code> field contains <em>unknown even bits</em>:


<ul>
<li>MUST NOT parse the remainder of the message.</li>

<li>MAY discard the message altogether.</li>

<li>SHOULD NOT connect to the node.</li></ul>
</li>

<li>MAY forward <code>node_announcement</code>s that contain an <em>unknown</em> <code>features</code> <em>bit</em>,
regardless of if it has parsed the announcement or not.</li>

<li>SHOULD ignore the first <code>address descriptor</code> that does NOT match the types
defined above.</li>

<li>if <code>addrlen</code> is insufficient to hold the address descriptors of the
known types:


<ul>
<li>SHOULD fail the connection.</li></ul>
</li>

<li>if <code>port</code> is equal to 0:


<ul>
<li>SHOULD ignore <code>ipv6_addr</code> OR <code>ipv4_addr</code>.</li></ul>
</li>

<li>if <code>node_id</code> is NOT previously known from a <code>channel_announcement</code> message,
OR if <code>timestamp</code> is NOT greater than the last-received <code>node_announcement</code>
from this <code>node_id</code>:


<ul>
<li>SHOULD ignore the message.</li></ul>
</li>

<li>otherwise:


<ul>
<li>if <code>timestamp</code> is greater than the last-received <code>node_announcement</code> from
this <code>node_id</code>:


<ul>
<li>SHOULD queue the message for rebroadcasting.</li>

<li>MAY choose NOT to queue messages longer than the minimum expected length.</li></ul>
</li></ul>
</li>

<li>MAY use <code>rgb_color</code> AND <code>alias</code> to reference nodes in interfaces.


<ul>
<li>SHOULD insinuate their self-signed origins.</li></ul>
</li>
</ul>

<h3 id="rationale-2">Rationale</h3>

<p>New node features are possible in the future: backwards compatible (or
optional) ones will have <em>odd</em> <code>feature</code> <em>bits</em>, incompatible ones will have
<em>even</em> <code>feature</code> <em>bits</em>. These may be propagated by nodes even if they
cannot process the announcements themselves.</p>

<p>New address types may be added in the future; as address descriptors have
to be ordered in ascending order, unknown ones can be safely ignored.
Additional fields beyond <code>addresses</code> may also be added in the futureâ€”with
optional padding within <code>addresses</code>, if they require certain alignment.</p>

<h3 id="securityconsiderationsfornodealiases">Security Considerations for Node Aliases</h3>

<p>Node aliases are user-defined and provide a potential avenue for injection
attacks, both during the process of rendering and during persistence.</p>

<p>Node aliases should always be sanitized before being displayed in
HTML/Javascript contexts or any other dynamically interpreted rendering
frameworks. Similarly, consider using prepared statements, input validation,
and escaping to protect against injection vulnerabilities and persistence
engines that support SQL or other dynamically interpreted querying languages.</p>

<ul>
<li><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet">Stored and Reflected XSS Prevention</a></li>

<li><a href="https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet">DOM-based XSS Prevention</a></li>

<li><a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet">SQL Injection Prevention</a></li>
</ul>

<p>Don't be like the school of <a href="https://xkcd.com/327/">Little Bobby Tables</a>.</p>

<h2 id="thechannel_updatemessage">The <code>channel_update</code> Message</h2>

<p>After a channel has been initially announced, each side independently
announces the fees and minimum expiry delta it requires to relay HTLCs
through this channel. Each uses the 8-byte channel shortid that matches the
<code>channel_announcement</code> and the 1-bit <code>channel_flags</code> field to indicate which end of the
channel it's on (origin or final). A node can do this multiple times, in
order to change fees.</p>

<p>Note that the <code>channel_update</code> gossip message is only useful in the context
of <em>relaying</em> payments, not <em>sending</em> payments. When making a payment
 <code>A</code> -> <code>B</code> -> <code>C</code> -> <code>D</code>, only the <code>channel_update</code>s related to channels
 <code>B</code> -> <code>C</code> (announced by <code>B</code>) and <code>C</code> -> <code>D</code> (announced by <code>C</code>) will
 come into play. When building the route, amounts and expiries for HTLCs need
 to be calculated backward from the destination to the source. The exact initial
 value for <code>amount_msat</code> and the minimal value for <code>cltv_expiry</code>, to be used for
 the last HTLC in the route, are provided in the payment request
 (see <a href="11-payment-encoding.md#tagged-fields">BOLT #11</a>).</p>

<ol>
<li>type: 258 (<code>channel_update</code>)</li>

<li>data:


<ul>
<li>[<code>64</code>:<code>signature</code>]</li>

<li>[<code>32</code>:<code>chain_hash</code>]</li>

<li>[<code>8</code>:<code>short_channel_id</code>]</li>

<li>[<code>4</code>:<code>timestamp</code>]</li>

<li>[<code>1</code>:<code>message_flags</code>]</li>

<li>[<code>1</code>:<code>channel_flags</code>]</li>

<li>[<code>2</code>:<code>cltv_expiry_delta</code>]</li>

<li>[<code>8</code>:<code>htlc_minimum_msat</code>]</li>

<li>[<code>4</code>:<code>fee_base_msat</code>]</li>

<li>[<code>4</code>:<code>fee_proportional_millionths</code>]</li>

<li>[<code>8</code>:<code>htlc_maximum_msat</code>] (option<em>channel</em>htlc_max)</li></ul>
</li>
</ol>

<p>The <code>channel_flags</code> bitfield is used to indicate the direction of the channel: it
identifies the node that this update originated from and signals various options
concerning the channel. The following table specifies the meaning of its
individual bits:</p>

<p>| Bit Position  | Name        | Meaning                          |
| ------------- | ----------- | -------------------------------- |
| 0             | <code>direction</code> | Direction this update refers to. |
| 1             | <code>disable</code>   | Disable the channel.             |</p>

<p>The <code>message_flags</code> bitfield is used to indicate the presence of optional
fields in the <code>channel_update</code> message:</p>

<p>| Bit Position  | Name                      | Field                            |
| ------------- | ------------------------- | -------------------------------- |
| 0             | <code>option_channel_htlc_max</code> | <code>htlc_maximum_msat</code>              |</p>

<p>Note that the <code>htlc_maximum_msat</code> field is static in the current
protocol over the life of the channel: it is <em>not</em> designed to be
indicative of real-time channel capacity in each direction, which
would be both a massive data leak and uselessly spam the network (it
takes an average of 30 seconds for gossip to propagate each hop).</p>

<p>The <code>node_id</code> for the signature verification is taken from the corresponding
<code>channel_announcement</code>: <code>node_id_1</code> if the least-significant bit of flags is 0
or <code>node_id_2</code> otherwise.</p>

<h3 id="requirements-3">Requirements</h3>

<p>The origin node:</p>

<ul>
<li>MAY create a <code>channel_update</code> to communicate the channel parameters to the
channel peer, even though the channel has not yet been announced (i.e. the
<code>announce_channel</code> bit was not set).


<ul>
<li>MUST NOT forward such a <code>channel_update</code> to other peers, for privacy
reasons.</li>

<li>Note: such a <code>channel_update</code>, one not preceded by a
<code>channel_announcement</code>, is invalid to any other peer and would be discarded.</li></ul>
</li>

<li>MUST set <code>signature</code> to the signature of the double-SHA256 of the entire
remaining packet after <code>signature</code>, using its own <code>node_id</code>.</li>

<li>MUST set <code>chain_hash</code> AND <code>short_channel_id</code> to match the 32-byte hash AND
8-byte channel ID that uniquely identifies the channel specified in the
<code>channel_announcement</code> message.</li>

<li>if the origin node is <code>node_id_1</code> in the message:


<ul>
<li>MUST set the <code>direction</code> bit of <code>channel_flags</code> to 0.</li></ul>
</li>

<li>otherwise:


<ul>
<li>MUST set the <code>direction</code> bit of <code>channel_flags</code> to 1.</li></ul>
</li>

<li>if the <code>htlc_maximum_msat</code> field is present:


<ul>
<li>MUST set the <code>option_channel_htlc_max</code> bit of <code>message_flags</code> to 1.</li>

<li>MUST set <code>htlc_maximum_msat</code> to the maximum value it will send through this channel for a single HTLC.


<ul>
<li>MUST set this to less than or equal to the channel capacity.</li>

<li>MUST set this to less than or equal to <code>max_htlc_value_in_flight_msat</code>
it received from the peer.</li>

<li>for channels with <code>chain_hash</code> identifying the Bitcoin blockchain:


<ul>
<li>MUST set this to less than 2^32.</li></ul>
</li></ul>
</li></ul>
</li>

<li>otherwise:


<ul>
<li>MUST set the <code>option_channel_htlc_max</code> bit of <code>message_flags</code> to 0.</li></ul>
</li>

<li>MUST set bits in <code>channel_flags</code> and <code>message_flags</code>that are not assigned a meaning to 0.</li>

<li>MAY create and send a <code>channel_update</code> with the <code>disable</code> bit set to 1, to
signal a channel's temporary unavailability (e.g. due to a loss of
connectivity) OR permanent unavailability (e.g. prior to an on-chain
settlement).


<ul>
<li>MAY sent a subsequent <code>channel_update</code> with the <code>disable</code> bit  set to 0 to
re-enable the channel.</li></ul>
</li>

<li>MUST set <code>timestamp</code> to greater than 0, AND to greater than any
previously-sent <code>channel_update</code> for this <code>short_channel_id</code>.


<ul>
<li>SHOULD base <code>timestamp</code> on a UNIX timestamp.</li></ul>
</li>

<li>MUST set <code>cltv_expiry_delta</code> to the number of blocks it will subtract from
an incoming HTLC's <code>cltv_expiry</code>.</li>

<li>MUST set <code>htlc_minimum_msat</code> to the minimum HTLC value (in millisatoshi)
that the channel peer will accept.</li>

<li>MUST set <code>fee_base_msat</code> to the base fee (in millisatoshi) it will charge
for any HTLC.</li>

<li>MUST set <code>fee_proportional_millionths</code> to the amount (in millionths of a
satoshi) it will charge per transferred satoshi.</li>

<li>SHOULD NOT create redundant <code>channel_update</code>s</li>
</ul>

<p>The receiving node:</p>

<ul>
<li>if the <code>short_channel_id</code> does NOT match a previous <code>channel_announcement</code>,
OR if the channel has been closed in the meantime:


<ul>
<li>MUST ignore <code>channel_update</code>s that do NOT correspond to one of its own
channels.</li></ul>
</li>

<li>SHOULD accept <code>channel_update</code>s for its own channels (even if non-public),
in order to learn the associated origin nodes' forwarding parameters.</li>

<li>if <code>signature</code> is not a valid signature, using <code>node_id</code> of the
double-SHA256 of the entire message following the <code>signature</code> field (including
unknown fields following <code>fee_proportional_millionths</code>):


<ul>
<li>MUST NOT process the message further.</li>

<li>SHOULD fail the connection.</li></ul>
</li>

<li>if the specified <code>chain_hash</code> value is unknown (meaning it isn't active on
the specified chain):


<ul>
<li>MUST ignore the channel update.</li></ul>
</li>

<li>if <code>timestamp</code> is NOT greater than that of the last-received
<code>channel_update</code> for this <code>short_channel_id</code> AND for <code>node_id</code>:


<ul>
<li>SHOULD ignore the message.</li></ul>
</li>

<li>otherwise:


<ul>
<li>if the <code>timestamp</code> is equal to the last-received <code>channel_update</code>
AND the fields (other than <code>signature</code>) differ:


<ul>
<li>MAY blacklist this <code>node_id</code>.</li>

<li>MAY forget all channels associated with it.</li></ul>
</li></ul>
</li>

<li>if the <code>timestamp</code> is unreasonably far in the future:


<ul>
<li>MAY discard the <code>channel_update</code>.</li></ul>
</li>

<li>otherwise:


<ul>
<li>SHOULD queue the message for rebroadcasting.</li>

<li>MAY choose NOT to for messages longer than the minimum expected length.</li></ul>
</li>

<li>if the <code>option_channel_htlc_max</code> bit of <code>message_flags</code> is 0:


<ul>
<li>MUST consider <code>htlc_maximum_msat</code> not to be present.</li></ul>
</li>

<li>otherwise:


<ul>
<li>if <code>htlc_maximum_msat</code> is not present or greater than channel capacity:


<ul>
<li>MAY blacklist this <code>node_id</code></li>

<li>SHOULD ignore this channel during route considerations.</li></ul>
</li>

<li>otherwise:


<ul>
<li>SHOULD consider the <code>htlc_maximum_msat</code> when routing.</li></ul>
</li></ul>
</li>
</ul>

<h3 id="rationale-3">Rationale</h3>

<p>The <code>timestamp</code> field is used by nodes for pruning <code>channel_update</code>s that are
either too far in the future or have not been updated in two weeks; so it
makes sense to have it be a UNIX timestamp (i.e. seconds since UTC
1970-01-01). This cannot be a hard requirement, however, given the possible case
of two <code>channel_update</code>s within a single second.</p>

<p>The explicit <code>option_channel_htlc_max</code> flag to indicate the presence
of <code>htlc_maximum_msat</code> (rather than having <code>htlc_maximum_msat</code> implied
by the message length) allows us to extend the <code>channel_update</code>
with different fields in future.  Since channels are limited to 2^32-1
millisatoshis in Bitcoin, the <code>htlc_maximum_msat</code> has the same restriction.</p>

<p>The recommendation against redundant <code>channel_update</code>s minimizes spamming the network,
however it is sometimes inevitable.  For example, a channel with a
peer which is unreachable will eventually cause a <code>channel_update</code> to
indicate that the channel is disabled, with another update re-enabling
the channel when the peer reestablishes contact.  Because gossip
messages are batched and replace previous ones, the result may be a
single seemingly-redundant update.</p>

<h2 id="querymessages">Query Messages</h2>

<p>Negotiating the <code>gossip_queries</code> option via <code>init</code> enables a number
of extended queries for gossip synchronization.  These explicitly
request what gossip should be received.</p>

<p>There are several messages which contain a long array of
<code>short_channel_id</code>s (called <code>encoded_short_ids</code>) so we utilize a
simple compression scheme: the first byte indicates the encoding, the
rest contains the data.</p>

<p>Encoding types:</p>

<ul>
<li><code>0</code>: uncompressed array of <code>short_channel_id</code> types, in ascending order.</li>

<li><code>1</code>: array of <code>short_channel_id</code> types, in ascending order, compressed with zlib deflate<sup><a href="#reference-1">1</a></sup></li>
</ul>

<p>Note that a 65535-byte zlib message can decompress into 67632120
bytes<sup><a href="#reference-2">2</a></sup>, but since the only valid contents
are unique 8-byte values, no more than 14 bytes can be duplicated
across the stream: as each duplicate takes at least 2 bits, no valid
contents could decompress to more then 3669960 bytes.</p>

<h3 id="thequery_short_channel_idsreply_short_channel_ids_endmessages">The <code>query_short_channel_ids</code>/<code>reply_short_channel_ids_end</code> Messages</h3>

<ol>
<li><p>type: 261 (<code>query_short_channel_ids</code>) (<code>gossip_queries</code>)</p></li>

<li><p>data:</p>

<ul>
<li>[<code>32</code>:<code>chain_hash</code>]</li>

<li>[<code>2</code>:<code>len</code>]</li>

<li>[<code>len</code>:<code>encoded_short_ids</code>]</li></ul></li>

<li><p>type: 262 (<code>reply_short_channel_ids_end</code>) (<code>gossip_queries</code>)</p></li>

<li><p>data:</p>

<p><ul>
<li>[<code>32</code>:<code>chain_hash</code>]</li></p>

<p><li>[<code>1</code>:<code>complete</code>]</li></ul></p></li>
</ol>

<p>This is a general mechanism which lets a node query for the
<code>channel_announcement</code> and <code>channel_update</code> messages for specific channels
(identified via <code>short_channel_id</code>s). This is usually used either because
a node sees a <code>channel_update</code> for which it has no <code>channel_announcement</code> or
because it has obtained previously unknown <code>short_channel_id</code>s
from <code>reply_channel_range</code>.</p>

<h4 id="requirements-4">Requirements</h4>

<p>The sender:</p>

<ul>
<li>MUST NOT send <code>query_short_channel_ids</code> if it has sent a previous <code>query_short_channel_ids</code> to this peer and not received <code>reply_short_channel_ids_end</code>.</li>

<li>MUST set <code>chain_hash</code> to the 32-byte hash that uniquely identifies the chain
that the <code>short_channel_id</code>s refer to.</li>

<li>MUST set the first byte of <code>encoded_short_ids</code> to the encoding type.</li>

<li>MUST encode a whole number of <code>short_channel_id</code>s to <code>encoded_short_ids</code></li>

<li>MAY send this if it receives a <code>channel_update</code> for a
<code>short_channel_id</code> for which it has no <code>channel_announcement</code>.</li>

<li>SHOULD NOT send this if the channel referred to is not an unspent output.</li>
</ul>

<p>The receiver:</p>

<ul>
<li>if the first byte of <code>encoded_short_ids</code> is not a known encoding type:


<ul>
<li>MAY fail the connection</li></ul>
</li>

<li>if <code>encoded_short_ids</code> does not decode into a whole number of <code>short_channel_id</code>:


<ul>
<li>MAY fail the connection.</li></ul>
</li>

<li>if it has not sent <code>reply_short_channel_ids_end</code> to a previously received <code>query_short_channel_ids</code> from this sender:


<ul>
<li>MAY fail the connection.</li></ul>
</li>

<li>MUST respond to each known <code>short_channel_id</code> with a <code>channel_announcement</code>
and the latest <code>channel_update</code> for each end


<ul>
<li>SHOULD NOT wait for the next outgoing gossip flush to send these.</li></ul>
</li>

<li>MUST follow with any <code>node_announcement</code>s for each <code>channel_announcement</code>


<ul>
<li>SHOULD avoid sending duplicate <code>node_announcements</code> in response to a single <code>query_short_channel_ids</code>.</li></ul>
</li>

<li>MUST follow these responses with <code>reply_short_channel_ids_end</code>.</li>

<li>if does not maintain up-to-date channel information for <code>chain_hash</code>:


<ul>
<li>MUST set <code>complete</code> to 0.</li></ul>
</li>

<li>otherwise:


<ul>
<li>SHOULD set <code>complete</code> to 1.</li></ul>
</li>
</ul>

<h4 id="rationale-4">Rationale</h4>

<p>Future nodes may not have complete information; they certainly won't have
complete information on unknown <code>chain_hash</code> chains.  While this <code>complete</code>
field cannot be trusted, a 0 does indicate that the sender should search
elsewhere for additional data.</p>

<p>The explicit <code>reply_short_channel_ids_end</code> message means that the receiver can
indicate it doesn't know anything, and the sender doesn't need to rely on
timeouts.  It also causes a natural ratelimiting of queries.</p>

<h3 id="thequery_channel_rangeandreply_channel_rangemessages">The <code>query_channel_range</code> and <code>reply_channel_range</code> Messages</h3>

<ol>
<li><p>type: 263 (<code>query_channel_range</code>) (<code>gossip_queries</code>)</p></li>

<li><p>data:</p>

<ul>
<li>[<code>32</code>:<code>chain_hash</code>]</li>

<li>[<code>4</code>:<code>first_blocknum</code>]</li>

<li>[<code>4</code>:<code>number_of_blocks</code>]</li></ul></li>

<li><p>type: 264 (<code>reply_channel_range</code>) (<code>gossip_queries</code>)</p></li>

<li><p>data:</p>

<p><ul>
<li>[<code>32</code>:<code>chain_hash</code>]</li></p>

<p><li>[<code>4</code>:<code>first_blocknum</code>]</li></p>

<p><li>[<code>4</code>:<code>number_of_blocks</code>]</li></p>

<p><li>[<code>1</code>:<code>complete</code>]</li></p>

<p><li>[<code>2</code>:<code>len</code>]</li></p>

<p><li>[<code>len</code>:<code>encoded_short_ids</code>]</li></ul></p></li>
</ol>

<p>This allows a query for channels within specific blocks.</p>

<h4 id="requirements-5">Requirements</h4>

<p>The sender of <code>query_channel_range</code>:</p>

<ul>
<li>MUST NOT send this if it has sent a previous <code>query_channel_range</code> to this peer and not received all <code>reply_channel_range</code> replies.</li>

<li>MUST set <code>chain_hash</code> to the 32-byte hash that uniquely identifies the chain
that it wants the <code>reply_channel_range</code> to refer to</li>

<li>MUST set <code>first_blocknum</code> to the first block it wants to know channels for</li>

<li>MUST set <code>number_of_blocks</code> to 1 or greater.</li>
</ul>

<p>The receiver of <code>query_channel_range</code>:</p>

<ul>
<li>if it has not sent all <code>reply_channel_range</code> to a previously received <code>query_channel_range</code> from this sender:


<ul>
<li>MAY fail the connection.</li></ul>
</li>

<li>MUST respond with one or more <code>reply_channel_range</code> whose combined range
cover the requested <code>first_blocknum</code> to <code>first_blocknum</code> plus
<code>number_of_blocks</code> minus one.</li>

<li>For each <code>reply_channel_range</code>:


<ul>
<li>MUST set with <code>chain_hash</code> equal to that of <code>query_channel_range</code>,</li>

<li>MUST encode a <code>short_channel_id</code> for every open channel it knows in blocks <code>first_blocknum</code> to <code>first_blocknum</code> plus <code>number_of_blocks</code> minus one.</li>

<li>MUST limit <code>number_of_blocks</code> to the maximum number of blocks whose
results could fit in <code>encoded_short_ids</code></li>

<li>if does not maintain up-to-date channel information for <code>chain_hash</code>:


<ul>
<li>MUST set <code>complete</code> to 0.</li></ul>
</li>

<li>otherwise:


<ul>
<li>SHOULD set <code>complete</code> to 1.</li></ul>
</li></ul>
</li>
</ul>

<h4 id="rationale-5">Rationale</h4>

<p>A single response might be too large for a single packet, and also a peer can
store canned results for (say) 1000-block ranges, and simply offer each reply
which overlaps the ranges of the request.</p>

<h3 id="thegossip_timestamp_filtermessage">The <code>gossip_timestamp_filter</code> Message</h3>

<ol>
<li>type: 265 (<code>gossip_timestamp_filter</code>) (<code>gossip_queries</code>)</li>

<li>data:


<ul>
<li>[<code>32</code>:<code>chain_hash</code>]</li>

<li>[<code>4</code>:<code>first_timestamp</code>]</li>

<li>[<code>4</code>:<code>timestamp_range</code>]</li></ul>
</li>
</ol>

<p>This message allows a node to constrain future gossip messages to
a specific range.  A node which wants any gossip messages would have
to send this, otherwise <code>gossip_queries</code> negotiation means no gossip
messages would be received.</p>

<p>Note that this filter replaces any previous one, so it can be used
multiple times to change the gossip from a peer.</p>

<h4 id="requirements-6">Requirements</h4>

<p>The sender:</p>

<ul>
<li>MUST set <code>chain_hash</code> to the 32-byte hash that uniquely identifies the chain
that it wants the gossip to refer to.</li>
</ul>

<p>The receiver:</p>

<ul>
<li>SHOULD send all gossip messages whose <code>timestamp</code> is greater or
equal to <code>first_timestamp</code>, and less than <code>first_timestamp</code> plus
<code>timestamp_range</code>.


<ul>
<li>MAY wait for the next outgoing gossip flush to send these.</li></ul>
</li>

<li>SHOULD restrict future gossip messages to those whose <code>timestamp</code>
is greater or equal to <code>first_timestamp</code>, and less than
<code>first_timestamp</code> plus <code>timestamp_range</code>.</li>

<li>If a <code>channel_announcement</code> has no corresponding <code>channel_update</code>s:


<ul>
<li>MUST NOT send the <code>channel_announcement</code>.</li></ul>
</li>

<li>Otherwise:


<ul>
<li>MUST consider the <code>timestamp</code> of the <code>channel_announcement</code> to be the <code>timestamp</code> of a corresponding <code>channel_update</code>.</li>

<li>MUST consider whether to send the <code>channel_announcement</code> after receiving the first corresponding <code>channel_update</code>.</li></ul>
</li>

<li>If a <code>channel_announcement</code> is sent:


<ul>
<li>MUST send the <code>channel_announcement</code> prior to any corresponding <code>channel_update</code>s and <code>node_announcement</code>s.</li></ul>
</li>
</ul>

<h4 id="rationale-6">Rationale</h4>

<p>Since <code>channel_announcement</code> doesn't have a timestamp, we generate a likely
one.  If there's no <code>channel_update</code> then it is not sent at all, which is most
likely in the case of pruned channels.</p>

<p>Otherwise the <code>channel_announcement</code> is usually followed immediately by a
<code>channel_update</code>. Ideally we would specify that the first (oldest) <code>channel_update</code>'s
timestamp is to be used as the time of the <code>channel_announcement</code>, but new nodes on
the network will not have this, and further would require the first <code>channel_update</code>
timestamp to be stored. Instead, we allow any update to be used, which
is simple to implement.</p>

<p>In the case where the <code>channel_announcement</code> is nonetheless missed,
<code>query_short_channel_ids</code> can be used to retrieve it.</p>

<h2 id="initialsync">Initial Sync</h2>

<p>If a node requires an initial sync of gossip messages, it will be flagged
in the <code>init</code> message, via a feature flag (<a href="09-features.md#assigned-localfeatures-flags">BOLT #9</a>).</p>

<p>Note that the <code>initial_routing_sync</code> feature is overridden (and should
be considered equal to 0) by the <code>gossip_queries</code> feature if the
latter is negotiated via <code>init</code>.</p>

<p>Note that <code>gossip_queries</code> does not work with older nodes, so the
value of <code>initial_routing_sync</code> is still important to control
interactions with them.</p>

<h3 id="requirements-7">Requirements</h3>

<p>A node:</p>

<ul>
<li>if the <code>gossip_queries</code> feature is negotiated:


<ul>
<li>MUST NOT relay any gossip messages unless explicitly requested.</li></ul>
</li>

<li>otherwise:


<ul>
<li>if it requires a full copy of the peer's routing state:


<ul>
<li>SHOULD set the <code>initial_routing_sync</code> flag to 1.</li></ul>
</li>

<li>upon receiving an <code>init</code> message with the <code>initial_routing_sync</code> flag set to
1:


<ul>
<li>SHOULD send gossip messages for all known channels and nodes, as if they were just
received.</li></ul>
</li>

<li>if the <code>initial_routing_sync</code> flag is set to 0, OR if the initial sync was
completed:


<ul>
<li>SHOULD resume normal operation, as specified in the following
<a href="#rebroadcasting">Rebroadcasting</a> section.</li></ul>
</li></ul>
</li>
</ul>

<h2 id="rebroadcasting">Rebroadcasting</h2>

<h3 id="requirements-8">Requirements</h3>

<p>A receiving node:</p>

<ul>
<li>upon receiving a new <code>channel_announcement</code> or a <code>channel_update</code> or
<code>node_announcement</code> with an updated <code>timestamp</code>:


<ul>
<li>SHOULD update its local view of the network's topology accordingly.</li></ul>
</li>

<li>after applying the changes from the announcement:


<ul>
<li>if there are no channels associated with the corresponding origin node:


<ul>
<li>MAY purge the origin node from its set of known nodes.</li></ul>
</li>

<li>otherwise:


<ul>
<li>SHOULD update the appropriate metadata AND store the signature
associated with the announcement.</li>

<li>Note: this will later allow the node to rebuild the announcement
for its peers.</li></ul>
</li></ul>
</li>
</ul>

<p>A node:</p>

<ul>
<li>if the <code>gossip_queries</code> feature is negotiated:


<ul>
<li>MUST not send gossip until it receives <code>gossip_timestamp_range</code>.</li></ul>
</li>

<li>SHOULD flush outgoing gossip messages once every 60 seconds, independently of
the arrival times of the messages.


<ul>
<li>Note: this results in staggered announcements that are unique (not
duplicated).</li></ul>
</li>

<li>MAY re-announce its channels regularly.


<ul>
<li>Note: this is discouraged, in order to keep the resource requirements low.</li></ul>
</li>

<li>upon connection establishment:


<ul>
<li>SHOULD send all <code>channel_announcement</code> messages, followed by the latest
<code>node_announcement</code> AND <code>channel_update</code> messages.</li></ul>
</li>
</ul>

<h3 id="rationale-7">Rationale</h3>

<p>Once the gossip message has been processed, it's added to a list of outgoing
messages, destined for the processing node's peers, replacing any older
updates from the origin node. This list of gossip messages will be flushed at
regular intervals; such a store-and-delayed-forward broadcast is called a
<em>staggered broadcast</em>. Also, such batching forms a natural rate
limit with low overhead.</p>

<p>The sending of all gossip on reconnection is naive, but simple,
and allows bootstrapping for new nodes as well as updating for nodes that
have been offline for some time.  The <code>gossip_queries</code> option
allows for more refined synchronization.</p>

<h2 id="htlcfees">HTLC Fees</h2>

<h3 id="requirements-9">Requirements</h3>

<p>The origin node:</p>

<ul>
<li>SHOULD accept HTLCs that pay a fee equal to or greater than:


<ul>
<li>fee<em>base</em>msat + ( amount<em>to</em>forward * fee<em>proportional</em>millionths / 1000000 )</li></ul>
</li>

<li>SHOULD accept HTLCs that pay an older fee, for some reasonable time after
sending <code>channel_update</code>.


<ul>
<li>Note: this allows for any propagation delay.</li></ul>
</li>
</ul>

<h2 id="pruningthenetworkview">Pruning the Network View</h2>

<h3 id="requirements-10">Requirements</h3>

<p>A node:</p>

<ul>
<li>SHOULD monitor the funding transactions in the blockchain, to identify
channels that are being closed.</li>

<li>if the funding output of a channel is being spent:


<ul>
<li>SHOULD be removed from the local network view AND be considered closed.</li></ul>
</li>

<li>if the announced node no longer has any associated open channels:


<ul>
<li>MAY prune nodes added through <code>node_announcement</code> messages from their
local view.


<ul>
<li>Note: this is a direct result of the dependency of a <code>node_announcement</code>
being preceded by a <code>channel_announcement</code>.</li></ul>
</li></ul>
</li>
</ul>

<h3 id="recommendationonpruningstaleentries">Recommendation on Pruning Stale Entries</h3>

<h4 id="requirements-11">Requirements</h4>

<p>A node:</p>

<ul>
<li>if a channel's latest <code>channel_update</code>s <code>timestamp</code> is older than two weeks
(1209600 seconds):


<ul>
<li>MAY prune the channel.</li>

<li>MAY ignore the channel.</li>

<li>Note: this is an individual node policy and MUST NOT be enforced by
forwarding peers, e.g. by closing channels when receiving outdated gossip
messages.</li></ul>
</li>
</ul>

<h4 id="rationale-8">Rationale</h4>

<p>Several scenarios may result in channels becoming unusable and its endpoints
becoming unable to send updates for these channels. For example, this occurs if
both endpoints lose access to their private keys and can neither sign
<code>channel_update</code>s nor close the channel on-chain. In this case, the channels are
unlikely to be part of a computed route, since they would be partitioned off
from the rest of the network; however, they would remain in the local network
view would be forwarded to other peers indefinitely.</p>

<h2 id="recommendationsforrouting">Recommendations for Routing</h2>

<p>When calculating a route for an HTLC, both the <code>cltv_expiry_delta</code> and the fee
need to be considered: the <code>cltv_expiry_delta</code> contributes to the time that
funds will be unavailable in the event of a worst-case failure. The relationship
between these two attributes is unclear, as it depends on the reliability of the
nodes involved.</p>

<p>If a route is computed by simply routing to the intended recipient and summing
the <code>cltv_expiry_delta</code>s, then it's possible for intermediate nodes to guess
their position in the route. Knowing the CLTV of the HTLC, the surrounding
network topology, and the <code>cltv_expiry_delta</code>s gives an attacker a way to guess
the intended recipient. Therefore, it's highly desirable to add a random offset
to the CLTV that the intended recipient will receive, which bumps all CLTVs
along the route.</p>

<p>In order to create a plausible offset, the origin node MAY start a limited
random walk on the graph, starting from the intended recipient and summing the
<code>cltv_expiry_delta</code>s, and use the resulting sum as the offset.
This effectively creates a <em>shadow route extension</em> to the actual route and
provides better protection against this attack vector than simply picking a
random offset would.</p>

<p>Other more advanced considerations involve diversification of route selection,
to avoid single points of failure and detection, and balancing of local
channels.</p>

<h3 id="routingexample">Routing Example</h3>

<p>Consider four nodes:</p>

<pre><code>   B
  / \
 /   \
A     C
 \   /
  \ /
   D
</code></pre>

<p>Each advertises the following <code>cltv_expiry_delta</code> on its end of every
channel:</p>

<ol>
<li>A: 10 blocks</li>

<li>B: 20 blocks</li>

<li>C: 30 blocks</li>

<li>D: 40 blocks</li>
</ol>

<p>C also uses a <code>min_final_cltv_expiry</code> of 9 (the default) when requesting
payments.</p>

<p>Also, each node has a set fee scheme that it uses for each of its
channels:</p>

<ol>
<li>A: 100 base + 1000 millionths</li>

<li>B: 200 base + 2000 millionths</li>

<li>C: 300 base + 3000 millionths</li>

<li>D: 400 base + 4000 millionths</li>
</ol>

<p>The network will see eight <code>channel_update</code> messages:</p>

<ol>
<li>A->B: <code>cltv_expiry_delta</code> = 10, <code>fee_base_msat</code> = 100, <code>fee_proportional_millionths</code> = 1000</li>

<li>A->D: <code>cltv_expiry_delta</code> = 10, <code>fee_base_msat</code> = 100, <code>fee_proportional_millionths</code> = 1000</li>

<li>B->A: <code>cltv_expiry_delta</code> = 20, <code>fee_base_msat</code> = 200, <code>fee_proportional_millionths</code> = 2000</li>

<li>D->A: <code>cltv_expiry_delta</code> = 40, <code>fee_base_msat</code> = 400, <code>fee_proportional_millionths</code> = 4000</li>

<li>B->C: <code>cltv_expiry_delta</code> = 20, <code>fee_base_msat</code> = 200, <code>fee_proportional_millionths</code> = 2000</li>

<li>D->C: <code>cltv_expiry_delta</code> = 40, <code>fee_base_msat</code> = 400, <code>fee_proportional_millionths</code> = 4000</li>

<li>C->B: <code>cltv_expiry_delta</code> = 30, <code>fee_base_msat</code> = 300, <code>fee_proportional_millionths</code> = 3000</li>

<li>C->D: <code>cltv_expiry_delta</code> = 30, <code>fee_base_msat</code> = 300, <code>fee_proportional_millionths</code> = 3000</li>
</ol>

<p><strong>B->C.</strong> If B were to send 4,999,999 millisatoshi directly to C, it would
neither charge itself a fee nor add its own <code>cltv_expiry_delta</code>, so it would
use C's requested <code>min_final_cltv_expiry</code> of 9. Presumably it would also add a
<em>shadow route</em> to give an extra CLTV of 42. Additionally, it could add extra
CLTV deltas at other hops, as these values represent a minimum, but chooses not
to do so here, for the sake of simplicity:</p>

<ul>
<li><code>amount_msat</code>: 4999999</li>

<li><code>cltv_expiry</code>: current-block-height + 9 + 42</li>

<li><code>onion_routing_packet</code>:


<ul>
<li><code>amt_to_forward</code> = 4999999</li>

<li><code>outgoing_cltv_value</code> = current-block-height + 9 + 42</li></ul>
</li>
</ul>

<p><strong>A->B->C.</strong> If A were to send 4,999,999 millisatoshi to C via B, it needs to
pay B the fee it specified in the B->C <code>channel_update</code>, calculated as
per <a href="#htlc-fees">HTLC Fees</a>:</p>

<pre><code>    fee_base_msat + ( amount_to_forward * fee_proportional_millionths / 1000000 )

200 + ( 4999999 * 2000 / 1000000 ) = 10199
</code></pre>

<p>Similarly, it would need to add B->C's <code>channel_update</code> <code>cltv_expiry</code> (20), C's
requested <code>min_final_cltv_expiry</code> (9), and the cost for the <em>shadow route</em> (42).
Thus, A->B's <code>update_add_htlc</code> message would be:</p>

<ul>
<li><code>amount_msat</code>: 5010198</li>

<li><code>cltv_expiry</code>: current-block-height + 20 + 9 + 42</li>

<li><code>onion_routing_packet</code>:


<ul>
<li><code>amt_to_forward</code> = 4999999</li>

<li><code>outgoing_cltv_value</code> = current-block-height + 9 + 42</li></ul>
</li>
</ul>

<p>B->C's <code>update_add_htlc</code> would be the same as B->C's direct payment above.</p>

<p><strong>A->D->C.</strong> Finally, if for some reason A chose the more expensive route via D,
A->D's <code>update_add_htlc</code> message would be:</p>

<ul>
<li><code>amount_msat</code>: 5020398</li>

<li><code>cltv_expiry</code>: current-block-height + 40 + 9 + 42</li>

<li><code>onion_routing_packet</code>:


<ul>
<li><code>amt_to_forward</code> = 4999999</li>

<li><code>outgoing_cltv_value</code> = current-block-height + 9 + 42</li></ul>
</li>
</ul>

<p>And D->C's <code>update_add_htlc</code> would again be the same as B->C's direct payment
above.</p>

<h2 id="references">References</h2>

<ol>
<li><a id="reference-1"><a href="https://www.ietf.org/rfc/rfc1950.txt">RFC 1950 "ZLIB Compressed Data Format Specification version 3.3</a></a></li>

<li><a id="reference-2"><a href="https://zlib.net/zlib_tech.html">Maximum Compression Factor</a></a></li>
</ol>

<p><img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons License" title="License CC-BY" />
<br>
This work is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p>